{"version":3,"file":"phaser-stroke-recognition.js","sources":["../src/phaser-stroke-recognition.ts"],"sourcesContent":["/// <reference path=\"../node_modules/phaser/types/phaser.d.ts\" />\nimport { Scene } from 'phaser';\n\ninterface Point {\n    x: number;\n    y: number;\n}\n\ninterface Stroke {\n    name: string;\n    matrix: boolean[][];\n    resolution: number;\n}\n\ninterface Bounds {\n    minX: number;\n    minY: number;\n    maxX: number;\n    maxY: number;\n    width: number;\n    height: number;\n}\n\ninterface Result{\n    hitsRatio: number;\n    hits: number;\n    fails: number;\n    sampleMatrix: boolean[][];\n    modelMatrix: boolean[][];\n}\n\nexport default class StrokeRec {\n    private scene: Scene;\n    strokes = new Map<string, Stroke>();\n\n    constructor(scene: Scene) {\n        this.scene = scene;\n    }\n\n\n    /**\n     * Generates a \"normalized\" array of 10x10 from an image.\n     * This image must be a black stroke over a transparent background.\n     * @param {string} name Unique name for this stroke\n     * @param {string} key The string key of the texture\n     * @param {(string | number)} [frame] String or index of the texture frame\n     * @param {number} [resolution = 10] Size of the matrix (default 10x10). High values reduce false positives and increase false negatives in stroke recognition. With low values the opposite occurs.\n     */\n    add(name: string, key: string, frame?: string | number, resolution: number = 10) {\n        const sc = this.scene;\n        const newStroke: Stroke = { name: name, matrix: [], resolution: resolution }\n\n\n        function generatePoints() {\n            const img = sc.textures.getFrame(key, frame);\n            const width = img.width;\n            const height = img.height;\n\n            let points: Point[] = [];\n\n            for (let y = 0; y < height; y++) {\n                for (let x = 0; x < width; x++) {\n                    if (sc.textures.getPixelAlpha(x, y, key, frame)) {\n                        points.push({ x: x, y: y });\n                    }\n                }\n            }// End 2xfor\n\n            return points;\n        }\n\n        const points = generatePoints();\n        const bounds = this.generateBounds(points);\n        const matrix = this.generateMatrix(points, bounds, resolution);\n\n        newStroke.matrix = matrix;\n\n        this.strokes.set(name, newStroke);\n    }\n\n    /**\n     * \n     * @param {Point[]} samplePoints Array of points ({x,y}) of the stroke to compare\n     * @param {string} strokeName Name of the model stroke\n     * @returns {Result} Object width results data\n     */\n    checkStroke(samplePoints: Point[], strokeName: string): Result | null{\n        const stroke = this.strokes.get(strokeName);\n        if (!stroke) {\n            return null;\n        }\n        const sampleBounds = this.generateBounds(samplePoints);\n        const sampleMatrix = this.generateMatrix(samplePoints, sampleBounds, stroke.resolution);\n\n        let hits = 0;\n        let fails = 0;\n\n        stroke.matrix.forEach((row, i) => {\n\n            row.forEach((cell, j) => {\n                let sample = sampleMatrix[i][j];\n                if (cell && sample) {\n                    hits++;\n                } else if(cell !== sample){\n                    fails++;\n                }\n            });\n        }); // End 2xforEach        \n\n        return {hitsRatio: hits/(hits + fails), hits: hits, fails: fails, sampleMatrix: sampleMatrix, modelMatrix: stroke.matrix};\n    }\n\n\n    /**\n     * Generates the bounds object with this properties (used in normalization process):\n     * * minX : left bound in pixels\n     * * minY: top bound in pixels\n     * * maxX: right bound in pixels\n     * * maxY: bottom bound in pixels\n     * * width\n     * * height\n     * @param {Point[]} points Array of points (point -> { x, y})\n     */\n    private generateBounds(points: Point[]): Bounds {\n        // Big values ensures them will be adjusted\n        const bounds: Bounds = { minX: 100000, minY: 100000, maxX: -100000, maxY: -100000, width: 0, height: 0 };\n\n        points.forEach((point) => {\n            if (point.x < bounds.minX) {\n                bounds.minX = point.x;\n            } else if (point.x > bounds.maxX) {\n                bounds.maxX = point.x;\n            }\n            if (point.y < bounds.minY) {\n                bounds.minY = point.y;\n            } else if (point.y > bounds.maxY) {\n                bounds.maxY = point.y;\n            }\n        });\n\n        bounds.width = bounds.maxX - bounds.minX;\n        bounds.height = bounds.maxY - bounds.minY;\n\n        return bounds;\n    }// End generateBounds\n\n    /**\n     * Transforms the array of raw points into a normalized array of booleans (matrix of alphas)\n     * Each cell of the matrix represents one sector of the image. If in that sector exists some positive alpha then its value will be \"true\"\n     * @param {Point[]} points Array of points (point -> { x, y})\n     * @param {Bounds} bounds Bounds object ({minX, minY, maxX, maxY, width, height})\n     * @param {number} [resolution = 10] Size of the matrix(default 10x10).  High values reduce false positives and increase false negatives in stroke recognition. With low values the opposite occurs.\n     */\n    private generateMatrix(points: Point[], bounds: Bounds, resolution: number = 10): boolean[][] {\n        function getEmptyArray() {\n            let arr = [];\n            for (let i = 0; i < resolution; i++) {\n                arr.push(new Array(resolution).fill(false));\n            }\n            return arr;\n        }\n\n        const matrix: boolean[][] = getEmptyArray();\n        const cellSize = (bounds.width > bounds.height) ? Math.floor(bounds.width / resolution) : Math.floor(bounds.height / resolution);\n\n        points.forEach((point) => {\n            let row = Math.floor((point.y - bounds.minY) / cellSize);\n            let column = Math.floor((point.x - bounds.minX) / cellSize);\n            row = Math.min(row, matrix.length - 1);\n            column = Math.min(column, matrix[0].length - 1);\n            matrix[row][column] = true;\n        });\n\n        return matrix;\n    }// End generateMatrix\n}"],"names":["scene","this","Map","add","name","key","frame","resolution","sc","newStroke","matrix","points","img","textures","getFrame","width","height","y","x","getPixelAlpha","push","generatePoints","bounds","generateBounds","generateMatrix","strokes","set","checkStroke","samplePoints","strokeName","stroke","get","sampleBounds","sampleMatrix","hits","fails","forEach","row","i","cell","j","sample","hitsRatio","modelMatrix","minX","minY","maxX","maxY","point","arr","Array","fill","getEmptyArray","cellSize","Math","floor","column","min","length"],"mappings":"0BAmCI,WAAYA,GAFZC,aAAU,IAAIC,IAGVD,KAAKD,MAAQA,6BAYjBG,IAAA,SAAIC,EAAcC,EAAaC,EAAyBC,YAAAA,IAAAA,EAAqB,IACzE,IAAMC,EAAKP,KAAKD,MACVS,EAAoB,CAAEL,KAAMA,EAAMM,OAAQ,GAAIH,WAAYA,GAqB1DI,EAlBN,WAOI,IANA,IAAMC,EAAMJ,EAAGK,SAASC,SAAST,EAAKC,GAChCS,EAAQH,EAAIG,MACZC,EAASJ,EAAII,OAEfL,EAAkB,GAEbM,EAAI,EAAGA,EAAID,EAAQC,IACxB,IAAK,IAAIC,EAAI,EAAGA,EAAIH,EAAOG,IACnBV,EAAGK,SAASM,cAAcD,EAAGD,EAAGZ,EAAKC,IACrCK,EAAOS,KAAK,CAAEF,EAAGA,EAAGD,EAAGA,IAKnC,OAAON,EAGIU,GACTC,EAASrB,KAAKsB,eAAeZ,GAC7BD,EAAST,KAAKuB,eAAeb,EAAQW,EAAQf,GAEnDE,EAAUC,OAASA,EAEnBT,KAAKwB,QAAQC,IAAItB,EAAMK,MAS3BkB,YAAA,SAAYC,EAAuBC,GAC/B,IAAMC,EAAS7B,KAAKwB,QAAQM,IAAIF,GAChC,IAAKC,EACD,YAEJ,IAAME,EAAe/B,KAAKsB,eAAeK,GACnCK,EAAehC,KAAKuB,eAAeI,EAAcI,EAAcF,EAAOvB,YAExE2B,EAAO,EACPC,EAAQ,EAcZ,OAZAL,EAAOpB,OAAO0B,QAAQ,SAACC,EAAKC,GAExBD,EAAID,QAAQ,SAACG,EAAMC,GACf,IAAIC,EAASR,EAAaK,GAAGE,GACzBD,GAAQE,EACRP,IACMK,IAASE,GACfN,QAKL,CAACO,UAAWR,GAAMA,EAAOC,GAAQD,KAAMA,EAAMC,MAAOA,EAAOF,aAAcA,EAAcU,YAAab,EAAOpB,WAc9Ga,eAAA,SAAeZ,GAEnB,IAAMW,EAAiB,CAAEsB,KAAM,IAAQC,KAAM,IAAQC,MAAO,IAAQC,MAAO,IAAQhC,MAAO,EAAGC,OAAQ,GAkBrG,OAhBAL,EAAOyB,QAAQ,SAACY,GACRA,EAAM9B,EAAII,EAAOsB,KACjBtB,EAAOsB,KAAOI,EAAM9B,EACb8B,EAAM9B,EAAII,EAAOwB,OACxBxB,EAAOwB,KAAOE,EAAM9B,GAEpB8B,EAAM/B,EAAIK,EAAOuB,KACjBvB,EAAOuB,KAAOG,EAAM/B,EACb+B,EAAM/B,EAAIK,EAAOyB,OACxBzB,EAAOyB,KAAOC,EAAM/B,KAI5BK,EAAOP,MAAQO,EAAOwB,KAAOxB,EAAOsB,KACpCtB,EAAON,OAASM,EAAOyB,KAAOzB,EAAOuB,KAE9BvB,KAUHE,eAAA,SAAeb,EAAiBW,EAAgBf,YAAAA,IAAAA,EAAqB,IASzE,IAAMG,EARN,WAEI,IADA,IAAIuC,EAAM,GACDX,EAAI,EAAGA,EAAI/B,EAAY+B,IAC5BW,EAAI7B,KAAK,IAAI8B,MAAM3C,GAAY4C,MAAK,IAExC,OAAOF,EAGiBG,GACtBC,EAAY/B,EAAOP,MAAQO,EAAON,OAAUsC,KAAKC,MAAMjC,EAAOP,MAAQR,GAAc+C,KAAKC,MAAMjC,EAAON,OAAST,GAUrH,OARAI,EAAOyB,QAAQ,SAACY,GACZ,IAAIX,EAAMiB,KAAKC,OAAOP,EAAM/B,EAAIK,EAAOuB,MAAQQ,GAC3CG,EAASF,KAAKC,OAAOP,EAAM9B,EAAII,EAAOsB,MAAQS,GAClDhB,EAAMiB,KAAKG,IAAIpB,EAAK3B,EAAOgD,OAAS,GACpCF,EAASF,KAAKG,IAAID,EAAQ9C,EAAO,GAAGgD,OAAS,GAC7ChD,EAAO2B,GAAKmB,IAAU,IAGnB9C"}